---
title: "Overview of YFAR functions"
date: "`r Sys.Date()`"
output:
  github_document:
    # toc: true
    # toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Overview of YFAR functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

> **BEFORE BEGINNING**
>
> This vignette assumes user has created and registered an app with the YDN
>

```{r, include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(YFAR)
library(dplyr)
library(usethis)
library(httptest)


```

*WooHoo!, finally an R package to get fantasy data from Yahoo!*

# Getting started

I registered an app at YDN and have my key and secret.  Whats now? How do I start using this package?

- There are two core functions you will need to run to get started:
  1. `y_create_token()`
  2. `y_games()`
  
## Create Token

### y_create_token

First a token is created using the KEY and SECRET given to you by the YDN.  
  
```{r Create token, eval=FALSE}

my_token <- y_create_token(my_key = "KEY", my_secret = "SECRET", app_name = "my_scraper")

```

Alright I did that but what exactly happened?

- This will create :
  - Token2.0 object.
  - Creates a file `.httr-oauth` which allows token refreshing.
  - If using version control will add `.httr-oauth` to `.gitignore`.

The token has some features which can help if you are getting http errors, specifically 401.

- Some of these include:
  - `my_token$can_refresh()` - check if token is refreshable
  - `my_token$refresh()` - refresh token

After creating your token you should not need to run `y_create_toke()` again.  You can just keep refreshing your existing token.

Now whenever you call a function you supply this value to the argument `token_name`.

## Get Game Info

Now you can retrieve the general data from all the games you have participated in or are currently participating in.

### y_games

Here's where you get to use your token for the first time.

Get your games

```{r, echo=FALSE}
my_token <-
    structure(
        list(),
        class = "Token2.0, Token, R6")

```

```{r, include=FALSE}
httptest::with_mock_api({
  games <- y_games(my_token)
})
```

```{r, eval = FALSE}

games <- y_games(my_token)
```

```{r}
games
```

**The league_key and league_id are what will be used to tell the functions from which leagues you want data**

For the examples here-on-in I'll use the league_key for a Yahoo! Public Fantasy Hockey League.

>
> 411.l.1239
>

# Functions

OK enough with all this setup stuff.  Where the data at?

## y_weeks

Use `y_weeks()` to get the match-up schedule for a game.  Here only the game key is necessary because the schedule for a game is set across all leagues.  All that changes is what week the league commences and the week playoffs start.

411 denotes 2021 Hockey

```{r y_weeks, include=FALSE}
with_mock_api({
weeks <- y_weeks(411, my_token)
})
```

```{r, eval=FALSE}
weeks <- y_weeks(411, my_token)
```

```{r}
weeks
```

Well that return from `y_weeks()` wasn't exactly what I was hoping for.

I know right? First we need to call some smaller functions to get the inputs for the functions that do the heavy lifting.

## y_teams

Retrieve data about teams in the league.  It may be handy to run this function upfront as it will return a column named `team_key` which can be used to get data for specific teams.

```{r y_teams, include=FALSE}
with_mock_api({
league_teams <- y_teams(league_id = "411.l.1239", token_name = my_token)
})
```

```{r, eval=FALSE}
league_teams <- y_teams(league_id = "411.l.1239", token_name = my_token)
```

```{r}
league_teams
```

> team keys can be supplied to a lot functions to get team specific data.

## y_league_settings

Retrieving the settings for a league will return a nested tibble of values

```{r League Settings, include=FALSE}
with_mock_api({
  league_settings <- y_league_settings(league_id = "411.l.1239", my_token)
})
```

```{r, eval=FALSE}
league_settings <- y_league_settings(league_id = "411.l.1239", my_token)
```

```{r}
league_settings
```

Pluck an element to view the tibble.  
```{r League Settings Stat Categories}
league_settings$data[4]
```

## y_team_stats

A league id will return team stats for the current week.

```{r, include=FALSE}
httptest::with_mock_api(
  team_stats_current_week <- y_team_stats(id = "411.l.1239", my_token)
)
```

```{r, eval=FALSE}
team_stats_current_week <- y_team_stats(id = "411.l.1239", my_token)
```

```{r}
team_stats_current_week
```

Set week to NULL returns season stats
```{r, include=FALSE}
httptest::with_mock_api(
  team_stats_season <- y_team_stats(id = "411.l.1239", my_token, week = NULL)
)
```

```{r, eval=FALSE}
team_stats_season <- y_team_stats(id = "411.l.1239", my_token, week = NULL)
```

```{r}
team_stats_season
```

Or select a week
```{r, inlcude=FALSE}
httptest::with_mock_api(
  week_5_team_stats <- y_team_stats(id = "411.l.1239", my_token, week = 5)
)
```

```{r, eval=FALSE}
week_5_team_stats <- y_team_stats(id = "411.l.1239", my_token, week = 5)
```

```{r}
week_5_team_stats
```

## y_transactions

I want to see all the moves made in my league this year. Can I do that?

Use `y_transactions` to retrieve transactions for a league or team.

> Note :
>
> waiver claims are special transaction not covered by `y_transactions`
>

Return all non-waiver transactions from a league
```{r, eval=FALSE}
# Not run
all_transactions <-
  y_transactions(id = "411.l.1239", token_name = my_token)
```

  - Arguments count and transaction_type can be supplied filter the return:
    - count :
      - a positive integer
    - transaction_type :
      - "commish"
      - "add"
      - "drop"
      - "trade"

Here are the last 5 transactions for team 1.

```{r team transactions count 5, include=FALSE}
with_mock_api({
  team_trans <- y_transactions(id = "411.l.1239.t.1", token_name = my_token, count = 5)
})
```

```{r, eval=FALSE}
team_trans <- y_transactions(id = "411.l.1239.t.1", token_name = my_token, count = 5)
```

```{r}
team_trans %>%
  select(type, timestamp, name_full)
```

The last 10 transactions in the league.

    y_transactions(id = "411.l.1239", token_name = my_token, count = 10)

The last trade in the league.

    y_transactions(id = "411.l.1239", token_name = my_token, count = 1, transaction_type = "trade")

Unfortunately as of right now you can filter by date or sort with this function.

## y_players vs y_player_slate

> Note
>
> These functions don't return player stats.  Use `y_player_stats()` to retrieve player stats.
>

y_players is intended to get a slice of players and takes arguments for specifying which and how many players to return.

y_player_slate is a while loop that will return all players that exist in your league.


### y_player_slate

Used to get all the players that exist in your league.  This function includes a progress bar.

> Note
>
> This function may be somewhat slow due to its use of janitor::make_clean_names
>

```{r y_player_slate, eval=FALSE}
# Not run
all_players_in_my_league <- y_player_slate(league_id = "411.l.1239", token_name = my_token)
```

### y_players

To get a slice of the players in your league.  By default returns 100 players sorted by "AR"

```{r basic y_players, include=FALSE}
with_mock_api({
players <- y_players("411.l.1239", token_name = my_token)
})
```

```{r, eval=FALSE}
players <- y_players("411.l.1239", token_name = my_token)
```

```{r}
players
```

Pass filters as ... arguments to customize your return.

- Valid filters :
  - position (Valid player positions, e.g. "C")
  - status
    - A (all available players),
    - FA (free agents only),
    - W (waivers only),
    - T (all taken players),
    - K (keepers only)
  - search (player name e.g. /players;search=smith)
  - sort
    - {stat_id} (valid stat in your league e.g. sort by goals {/sort="1"}),
    - NAME (last, first),
    - OR (overall rank),
    - AR (actual rank),
    - PTS (fantasy points)
    - start (Any integer 0 or greater e.g. /players;start=25)
    - count (Any integer b/t 0 & 25 /players;count=5)

Top 10 players by actual rank ("AR")
```{r y_players top 10, include=FALSE}
with_mock_api({
top_10_ar_players <- y_players("411.l.1239", token_name = my_token, number_of_players = 10, start = 0, sort = "AR", status = "ALL", debug = FALSE)
})
```


```{r, eval=FALSE}
top_10_ar_players <- y_players("411.l.1239", token_name = my_token, number_of_players = 10, start = 0, sort = "AR", status = "ALL", debug = FALSE)
```

```{r}
top_10_ar_players
```

Top 10 players sorted by goals (stat="1")

```{r y_players top 10 goals, include=FALSE}
with_mock_api({
  top_10_ar_players <-
  y_players("411.l.1239", token_name = my_token, number_of_players = 10, start = 0, sort = "1", status = "ALL", debug = FALSE)
})
```

```{r, eval=FALSE}
top_10_ar_players <-
  y_players("411.l.1239", token_name = my_token, number_of_players = 10, start = 0, sort = "1", status = "ALL", debug = FALSE)
```

```{r}
top_10_ar_players
```

## y_draft_results

Takes a league or team id.
```{r y_draft_results, eval=FALSE}

league_draft <- y_draft_results("411.l.1239", token_name = my_token, debug = FALSE)

or

team_draft <- y_draft_results("411.l.1239.t.1", token_name = my_token, debug = FALSE)
```

```{r, include=FALSE}
with_mock_api({
  team_draft <- y_draft_results("411.l.1239.t.1", token_name = my_token, debug = FALSE)
})
```

Here's the draft for team 1
```{r, eval=FALSE}
team_draft <- y_draft_results("411.l.1239.t.1", token_name = my_token, debug = FALSE)
```

```{r}
team_draft
```

The Yahoo! API doesn't return player names with this call but can be used with `y_players()` or `y_rosters()`

### Examples

See which players drafted by a team are still currently on the team's roster.

```{r, include=FALSE}
with_mock_api({
remaining_players <-
  dplyr::inner_join(
    y_rosters(id = "411.l.1239.t.1", my_token, debug = FALSE),
    y_draft_results(id = "411.l.1239.t.1", my_token, debug = FALSE),
    by = "player_key"
  ) %>%
  dplyr::select("name_full")
})
```

```{r, eval=FALSE}
remaining_players <-
  dplyr::inner_join(
    y_rosters(id = "411.l.1239.t.1", my_token, debug = FALSE),
    y_draft_results(id = "411.l.1239.t.1", my_token, debug = FALSE),
    by = "player_key"
  ) %>%
  dplyr::select("name_full")
```

```{r}
remaining_players
```

## y_matchups

How do I see my matchups? Default arguments return past and current matchups
```{r y_matchup, include=FALSE}
with_mock_api({
my_matchups <- y_matchups("411.l.1239.t.1", my_token)
})
```

```{r, eval=FALSE}
my_matchups <- y_matchups("411.l.1239.t.1", my_token)
```

```{r}
my_matchups
```

Also takes a week argument. Return week 8 matchup.
```{r y_matchup week 8, eval=FALSE}
# Not run
my_week_8_matchup <- y_matchups("411.l.1239.t.1", my_token, week = 8)
```

### Examples

Multiple weeks

    y_matchups("411.l.1239.t.1", my_token, week = c(1, 8))

Multiple teams

    teams <- c("411.l.1239.t.1", "411.l.1239.t.8")

    purrr::map_df(teams, y_matchups, my_token, week = 1)

Multiple teams with multiple weeks

    purrr::map_df(teams, y_matchups, my_token, week = c(1, 8))

## y_standings

Get standings data
```{r, include=FALSE}
standings <- y_standings("411.l.1239", my_token)
```

```{r, eval=FALSE}
standings <- y_standings("411.l.1239", my_token)
```

```{r}
standings
```

## y_rosters

I want to see the current roster for each team in my league.

To retrieve the players which makeup a roster or rosters.  Accepts a team_key or league_key.

### league rosters

Here a league key is supplied and a tibble with the current roster for each team is returned.
```{r Rosters, eval=FALSE}
# Not run
rosters <- y_rosters(id = "411.l.1239", token_name = my_token)
```

### Team Roster

Alternatively supplying a team key will return the current roster for that team.
```{r y_roster team, include=FALSE}
with_mock_api({
team_roster <- y_rosters(id = "411.l.1239.t.1", token_name = my_token)
})
```

```{r, eval=FALSE}
team_roster <- y_rosters(id = "411.l.1239.t.1", token_name = my_token)
```

```{r}
team_roster
```

### Date

A date argument can be supplied.
```{r team roster with date, eval=FALSE}
# Not run
team_1_roster_w_date <- y_rosters(id = "411.l.1239.t.1", token_name = my_token, date = "2021-10-12")
```

### Examples

#### Multiple dates

Map over multiple dates
```{r map over multiple dates}
# create a date sequence from fantasy week 1 using return from `y_weeks()`
week_1 <- 
  seq.Date(from = lubridate::ymd(weeks$start[1]), to = lubridate::ymd(weeks$end[1]), by = 1)
```

```{r, eval=FALSE}
# map over the date sequence to get roster for those dates
#Not run
purrr::map_df(.x = week_1, .f = y_rosters, id = "411.l.1239.t.1", token_name = my_token)
```

#### Multiple teams

You can map over multiple teams.  Here team 1 and 2 are returned in a list.

    purrr::map(
    c("411.l.1239.t.1", "411.l.1239.t.2"), 
    y_rosters, 
    token_name = my_token, 
    debug = FALSE)

#### Multiple Teams and Dates

    purrr::map_df(
    .x = c("411.l.1239.t.1", "411.l.1239.t.1"),
    .f = y_rosters,
    token_name = my_token,
    game_date = c("2021-12-01", "2021-12-02"),
    debug = FALSE)

## y_player_stats

Let's see some player stats! To get stats for players using player keys.

Here's a basic example using Leon Draisaitl.

```{r y_player_stats, include=FALSE}
with_mock_api({
draisaitl_stats <- y_player_stats(players = "411.p.6369", token_name = my_token)
})
```

```{r, eval=FALSE}
draisaitl_stats <- y_player_stats(players = "411.p.6369", token_name = my_token)
```

```{r}
draisaitl_stats %>% 
  dplyr::select(g:sog)
```

Well that's bs why can't I just use the player's name!? Where did you get that player key number anyways?

  - The player key can be found using:
      - `y_player_slate()`
      - `y_players()`
      - `y_rosters()`

Here's an example from the public league.

```{r, include=FALSE}
with_mock_api({
players <- y_rosters(id = "411.l.1239.t.1", token_name = my_token)
})
```

```{r, eval=FALSE}
players <- y_rosters(id = "411.l.1239.t.1", token_name = my_token)
```

```{r}
players %>%
  dplyr::select(player_key, name_full)
```

OK so what? I have to write down those numbers and run this function for each player?

Nope! `y_player_stats()` can take a vector of player keys.  Here's how using our roster from the last example.

```{r, include=FALSE}
with_mock_api({
  my_player_stats <- y_player_stats(players = players$player_key, token_name = my_token)
})
```

```{r, eval=FALSE}
my_player_stats <- y_player_stats(players = players$player_key, token_name = my_token)
```

```{r}
my_player_stats %>% 
  dplyr::select(name_full, g:sog)
```

Don't worry about the NA's in the goalie stats.  I'm only showing you skater stats.

OK well that's pretty good but what if I only want stats for my players from yesterday?

```{r, include=FALSE}
with_mock_api({
yesterday_stats <-
  y_player_stats(
    players = players$player_key,
    token_name = my_token,
    game_date = Sys.Date() - 1
  )
})
```

```{r, eval=FALSE}
yesterday_stats <-
  y_player_stats(
    players = players$player_key,
    token_name = my_token,
    date = Sys.Date() - 1
  )
```

```{r}
yesterday_stats %>% 
   dplyr::select(name_full, g:sog)
```

And can it get my players stats for week 7?  Yes! You can supply a vector of dates to `y_player_stats()`

Using y_weeks we can find the start and end date for week 7.

```{r}
week_7 <- 
  weeks %>%
  dplyr::filter(week == 7) %>%
  dplyr::select(start, end)
```

And create a date sequence
```{r week 7 date sequence}
week_7_dates <-
  seq.Date(from = as.Date(week_7$start),
           to = as.Date(week_7$end),
           by = 1)
```

Week 7 player record count
```{r week 7 player count, include=FALSE}
with_mock_api({
week_7_stats <-
  y_player_stats(
    players = players$player_key,
    token_name = my_token,
    game_date = week_7_dates
  )
})

```

```{r, eval=FALSE}
week_7_stats <-
  y_player_stats(
    players = players$player_key,
    token_name = my_token,
    game_date = week_7_dates
  )
```

```{r}
week_7_stats %>% 
  dplyr::count(name_full)
```

```{r}
week_7_stats %>%
  dplyr::select(name_full, g:sog) %>%
  dplyr::group_by(name_full) %>%
  dplyr::group_split() %>%
  purrr::pluck(1)
```

